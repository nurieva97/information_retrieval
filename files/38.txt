Гость
Освой программирование играючи
Сайт Александра Климова
/* Моя кошка замечательно разбирается в программировании. Стоит мне объяснить проблему ей - и все становится ясно. */ John Robbins, Debugging Applications, Microsoft Press, 2000

Статья проплачена кошками - всемирно известными производителями котят.
Если статья вам понравилась, то можете поддержать проект.
Файл манифеста AndroidManifest.xml предоставляет основную информацию о программе системе. Каждое приложение должно иметь свой файл AndroidManifest.xml. Редактировать файл манифеста можно вручную, изменяя XML-код или через визуальный редактор Manifest Editor (Редактор файла манифеста), который позволяет осуществлять визуальное и текстовое редактирование файла манифеста приложения.
Файл манифеста инкапсулирует всю архитектуру Android-приложения, его функциональные возможности и конфигурацию. В процессе разработки приложения вам придется постоянно редактировать данный файл, изменяя его структуру и дополняя новыми элементами и атрибутами.
Корневым элементом манифеста является <manifest>. Помимо данного элемента обязательными элементами является теги <application> и <uses-sdk>. Элемент <application> является основным элементом манифеста и содержит множество дочерних элементов, определяющих структуру и работу приложения. Порядок расположения элементов, находящихся на одном уровне, произвольный. Все значения устанавливаются через атрибуты элементов. Кроме обязательных элементов, упомянутых выше, в манифесте по мере необходимости используются другие элементы.
Элемент <manifest> является корневым элементом манифеста. По умолчанию Eclipse создает элемент с четырьмя атрибутами:
Элемент <permission> объявляет разрешение, которое используется для ограничения доступа к определенным компонентам или функциональности данного приложения. В этой секции описываются права, которые должны запросить другие приложения для получения доступа к вашему приложению. Приложение может также защитить свои собственные компоненты (деятельности, службы, приемники широковещательных намерений и контент-провайдеры) разрешениями. Оно может использовать любое из системных разрешений, определенных Android или объявленных другими приложениями, а также может определить свои собственные разрешения.
Элемент <uses-permission> запрашивает разрешение, которые приложению должны быть предоставлены системой для его нормального функционирования. Разрешения предоставляются во время установки приложения, а не во время его работы.
Наиболее распространенные разрешения
Элемент <permission-tree> объявляет базовое имя для дерева разрешений. Этот элемент объявляет не само разрешение, а только пространство имен, в которое могут быть помещены дальнейшие разрешения.
Элемент <permission-group> определяет имя для набора логически связанных разрешений. Это могут быть как объявленные в этом же манифесте с элементом <permission> разрешения, так и объявленные в другом месте. Этот элемент не объявляет разрешение непосредственно, только категорию, в которую могут быть помещены разрешения. Разрешение можно поместить в группу, назначив имя группы в атрибуте permissionGroup элемента <permission>.
Элемент <instrumentation> объявляет объект instrumentation, который дает возможность контролировать взаимодействие приложения с системой. Обычно используется при отладке и тестировании приложения и удаляется из release-версии приложения.
Элемент <uses-sdk> позволяет объявлять совместимость приложения с указанной версией (или более новыми версиями API) платформы Android. Уровень API, объявленный приложением, сравнивается с уровнем API системы мобильного устройства, на который инсталлируется данное приложение.
Элемент <uses-configuration> указывает требуемую для приложения аппаратную и программную конфигурацию мобильного устройства. Например, приложение могло бы определить требования обязательного наличия на устройстве физической клавиатуры или USB-nopTa. Спецификация используется, чтобы избежать установки приложения на устройствах, которые не поддерживают требуемую конфигурацию. Если приложение может работать с различными конфигурациями устройства, необходимо включить в манифест отдельные элементы <uses-configuration> для каждой конфигурации. Вы можете задать любую комбинацию, содержащие следующие устройства
Приложение не будет устанавливаться на устройстве, которое не соответствует заданной вами конфигурации. В идеале, вы должны разработать такое приложение, которое будет работать с любым сочетанием устройств ввода. В этом случае <uses-configuration> не нужен.
Элемент <uses-feature> объявляет определенную функциональность, требующуюся для работы приложения. Таким образом, приложение не будет установлено на устройствах, которые не имеют требуемую функциональность. Например, приложение могло бы определить, что оно требует камеру с автофокусом. Если устройство не имеет встроенную камеру с автофокусом, приложения не будет инсталлировано.
Пример
Список можно увидеть здесь.
Можно переопределить требование по умолчанию, добавив атрибут required со значением false. Например, если вашей программе не требуется, чтобы камера поддерживала автофокус, то используйте вариант:
Элемент <supports-screens> определяет разрешение экрана, требуемое для функционирования устройства. Данный тег позволяет указать размеры экран, для которого был спроектировано приложение. Система будет масштабировать ваше приложение на основе ваших макетов на тех устройствах, которые поддерживают указанные вами разрешения экран. Для других случаев система будет растягивать макет по мере возможности.
Возможные значения
По умолчанию, для каждого атрибута установлено значение true. Вы можете указать, какие размеры экранов ваше приложение не поддерживает.
Начиная с API 13 (Android 3), у тега появились новые атрибуты:
Элемент <application> один из основных элементов манифеста, содержащий описание компонентов приложения, доступных в пакете: стили, значок и др. Содержит дочерние элементы, которые объявляют каждый из компонентов, входящих в состав приложения. В манифесте может быть только один элемент <application>.
Элемент <activity> объявляет активность. Если приложение содержит несколько активностей, не забывайте объявлять их в манифесте, создавая для каждой из них свой элемент <activity>. Если активность не объявлена в манифесте, она не будет видна системе и не будет запущена при выполнении приложения или будет выводиться сообщение об ошибке.
Для этого класса зарегистрирован фильтр вызовов, определяющий, что это действие запущено в приложении (действие android:name=«android.intent.action.MAIN»). Определение категории (категория android:name=«android.intent.category.LAUNCHER» ) определяет, что это приложение добавлено в директорию приложений на Android-устройстве. Значения @ направляют файлы ресурсов, которые содержат актуальные значения. Это упрощает работу с разными ресурсами, такими как строки, цвета, значки.
Пример:
Элемент <activity> содержит множество других атрибутов, определяющих разрешения, ориентацию экрана и т. д.
При изменении языка, региона или аппаратной конфигурации Android прерывает работу всех приложений и затем запускает их повторно, перезагружая значения из ресурсов. Подобное поведение не всегда уместно и желательно. Например, некоторые изменения конфигурации (ориентация экрана в пространстве, доступность клавиатуры) могут произойти только лишь из-за того, что пользователь повернул устройство или выдвинул клавиатуру. Вы можете настраивать, каким образом ваше приложение будет реагировать на подобные изменения, обнаруживая их и выполняя собственные действия. Чтобы заставить Активность отслеживать изменения конфигурации при выполнении программы, добавьте в ее узел в манифесте атрибут android:configChanges, указав, какие именно события хотите обрабатывать.
Перечислим некоторые значения, с помощью которых можно описать изменения конфигурации:
В некоторых случаях одновременно будут срабатывать несколько событий. Например, когда пользователь выдвигает клавиатуру, большинство устройств генерируют события keyboardHidden и orientation. Вы можете выбирать несколько событий, которые хотите обрабатывать самостоятельно, разделяя их символом |.
Наличие атрибута android:configChanges отменяет перезапуск приложения при заданных изменениях конфигурации. Вместо этого внутри активности срабатывает метод onConfigurationChanged(). Переопределите его, чтобы появилась возможность обрабатывать изменения в конфигурации. Используйте переданный объект Configuration, чтобы получить новые значения. Не забудьте вызвать одноименный метод из родительского класса и перезагрузить измененные значения со всех ресурсов, которые используются внутри активности.
На момент вызова метода, все данные из ресурсов будут обновлены, поэтому применять метод можно без опаски.
Любые изменения конфигурации, которые не были явно помечены для обработки внутри вашего приложения, приведут к перезапуску активности, минуя вызов метода onConfigurationChanged().
Каждый тег <activity> поддерживает вложенные узлы <intent-filter>. Элемент <intent-filter> определяет типы намерений, на которые могут ответить деятельность, сервис или приемник намерений. Фильтр намерений объявляет возможности его родительского компонента — что могут сделать деятельность или служба и какие типы рассылок получатель может обработать. Фильтр намерений предоставляет для компонентов-клиентов возможность получения намерений объявляемого типа, отфильтровывая те, которые не значимы для компонента, и содержит дочерние элементы <action>, <category>, <data>.
Элемент <action> добавляет действие к фильтру намерений. Элемент <intent-filter> должен содержать один или более элементов <action>. Если в элементе <intent-fiiter> не будет этих элементов, то объекты намерений не пройдут через фильтр. Пример объявления действия:
Элемент <category> определяет категорию компонента, которую должно обработать намерение. Это строковые константы, определенные в классе intent, например:
Элемент <data> добавляет спецификацию данных к фильтру намерений. Спецификация может быть только типом данных (атрибут mimeType), URI или ТИПОМ данных вместе с URI. Значение URI определяется отдельными атрибутами для каждой из его частей, т. е. URI делитСЯ на части: android:scheme, android:host, android:port, android:path или android:pathPrefix, android:pathPattern.
Элемент <meta-data> определяет пару "имя-значение" для элемента дополнительных произвольных данных, которыми можно снабдить родительский компонент. Составляющий элемент может содержать любое число элементов <meta-data>.
Элемент <activity-alias> — это псевдоним для Activity, определенной в атрибуте targetActivity. Целевая деятельность должна быть в том же самом приложении, что и псевдоним, и должна быть объявлена перед псевдонимом деятельности в манифесте. Псевдоним представляет целевую деятельность как независимый объект. У псевдонима может быть свой собственный набор фильтров намерений, определяющий, какие намерения могут активизировать целевую деятельность и как система будет обрабатывать эту деятельность. Например, фильтры намерений на псевдониме деятельности могут определить флаги android:name="android.intent.action.MAIN" и android:name="android.intent.category.LAUNCHER", заставляя целевую деятельность загружаться при запуске приложения даже в том случае, когда в фильтрах намерений на целевой деятельности эти флаги не установлены.
Элемент <service> объявляет службу как один из компонентов приложения. Все службы должны быть представлены элементом <service> в файле манифеста. Службы, которые не были объявлены, не будут обнаружены системой и никогда не будут запущены. Этот элемент имеет много атрибутов, определяющих имя, доступность, разрешения, процесс и т. д. Поддерживает вложенные узлы <intent-fiiter>
Элемент <receiver> объявляет приемник широковещательных намерений как один из компонентов приложения. Приемники широковещательных намерений дают возможность приложениям получить намерения, которые переданы системой или другими приложениями, даже когда другие компоненты приложения не работают.
Элемент <provider> объявляет контент-провайдера (источник данных) для управления доступом к базам данных. Все контент-провайдеры, которые являются частью приложения, должны быть представлены в элементах <provider> в файле манифеста. Если они не объявлены, они не будут работать, т. к. система их не сможет увидеть. Элемент <provider> содержит свой набор дочерних элементов для установления разрешений доступа к данным:
Этот элемент имеет много атрибутов, определяющих имя, доступность, разрешения, процесс и т. д.
Элемент <grant-uri-permission> является дочерним элементом для <provider>. Он определяет, для кого можно предоставить разрешения на подмножества данных контент-провайдера. Предоставление разрешения является способом допустить к подмножеству данных, предоставляемым контент-провайдером, клиента, у которого нет разрешения для доступа к полным данным. Если атрибут granturiPermissions контент-провайдера имеет значение true, то разрешение предоставляется для любых данных, поставляемых контент-провайдером. Однако, если атрибут поставлен в false, разрешение можно предоставить только подмножествам данных, которые определены этим элементом. Контент-провайдер может содержать любое число элементов <grant-uri-permission>.
Элемент <path-permission> — дочерний элемент для <provider>. Определяет путь и требуемые разрешения для определенного подмножества данных в пределах поставщика оперативной информации. Этот элемент может быть определен многократно, чтобы поставлять множественные пути.
Элемент <uses-library> определяет общедоступную библиотеку, с которой должно быть скомпоновано приложение. Этот элемент указывает системе на необходимость включения кода библиотеки в загрузчик классов для пакета приложения. Каждый проект связан по умолчанию с библиотеками Android, в которые включены основные пакеты для сборки приложений (с классами общего назначения типа Activity, Service, Intent, View, Button, Application, ContentProvider и т. д.). Однако некоторые пакеты находятся в отдельных библиотеках, которые автоматически не компонуются с приложением. Если же приложение использует пакеты из этих библиотек или других, от сторонних разработчиков, необходимо сделать явное связывание с этими библиотеками и манифест обязательно должен содержать отдельный элемент <uses-library>.
